<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Berners-Lee! - Olvasónapló</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>C++ vs Java</title>
        <para>
            C++: Benedek Zoltán, Levendovszky Tihamér Szoftverfejlesztés C++ nyelven
        </para>
		<para>
            Java: Nyékyné Dr. Gaizler Judit et al. Java 2 útikalauz programozóknak 5.0 I-
        </para>
		<para>
            Ebből a két könyvből pár oldalas esszé jellegű kidolgozást kérek, Java és C++
			összehasonlítás mentén, pl. kb.: kifejezés fogalom ua., Javában minden objektum
			referencia, mindig dinamikus a kötés, minden függvény virtuális, klónozás stb.
        </para>
		<para>
		A Java egy objektumorientált nyelv, ami azt jelenti, hogy egy Java program objektumok, és ezek mintáinak tekinthető osztályok összessége. Egy osztály változókból, valamint metódusokból épül fel. A változókban adatokat lehet tárolni, a metódusokban pedig megadjuk, hogy milyen műveleteket szeretnénk elvégezni rajtuk. 
		</para>
		<para>
		Mikor változókat használunk meg kell adni azok típusát is. Ilyen például a boolean, ami igaz/hamis értéket vesz fel, a char, ami 16 bites Unicode karakter, a byte, a short, az int és a long, ami 8, 16, 32, és 64 biten tárol előjeles egész számokat, illetve a float és a double, melyek 32 és 64 bites lebegőpontos számok tárolására szolgálnak. Ezen kívül vannak még sztringek, melyekre a String típussal hivatkozunk.  A változókhoz = operátorral tudunk értéket rendelni. Arra is figyelnünk kell, hogy ezeket a változókat hogyan nevezzük el. Csak betűvel kezdődhetnek, majd betűvel vagy számmal folytatódhatnak, betűk közé tartozik még a _ és a $ karakter.
		</para>
		<para>
		Java nyelvben [] jelöléssel adjuk meg a tömböket. Ezek indexelése 0-val kezdődik. A tömb értéket a new operátorral adjuk meg. Méretét a length használatával kérdezhetjük le. 
		</para>
		<para>Egyszerű típusok és objektumok inicializálásához literálokat használunk: objektumok (az egyetlen literál a null, bárhol használható objektumreferencia helyett), logikai érték (true vagy false értékek), egész számok (lehet oktális, hexadecimális vagy decimális), lebegőpontos számok (szerepelhet benne tizedespont vagy exponens is), karakterek (aposztrófok között adjuk meg), szövegek (idézőjelek között adjuk meg), osztályok.</para>
		<para>Felsorolási típusokkal definiálhatunk könnyen megjegyezhető, kifejező nevű értékeket tartalmazó típusokat, például a hét napjait így adnánk meg: enum Napok {HÉTFŐ, KEDD, …, VASÁRNAP;}. Ezekhez a nyelv több hasznos műveletet biztosít. Az ordinal függvény megadja, hogy egy típusérték hányadik helyen szerepel a felsorolásban. Egy felsorolási típus értékeit tömbbe is tehetjük, erre szolgál a values függvény.</para>
		<para>Javában beszélhetünk még elágazásokról és ciklusokról is. Az elágazásoknak két féle szerkezete lehet. Egyszerű elágazásokhoz az if szerkezetet használjuk melynek szintaxisa a következő: if (logikai kifejezés) utasítás1 else utasítás2. Összetett elágazásoknál a switch elágazást használjuk. Itt a fejrészben lévő kifejezés lesz kiértékelve, ezt követően pedig a case ágakban lévő címkeértékek lesznek megvizsgálva. Ha valamelyik címkeérték megegyezik a fejlécben lévő kifejezéssel, akkor az abban lévő utasítások lesznek végrehajtva a switch végéig vagy a break utasításig. Ha nincs megfelelő címke, akkor a default ág kerül végrehajtásra. Ciklusok esetében beszélhetünk előltesztelő, hátultesztelő, léptető, valamint bejáró ciklusokról. Az előltesztelő ciklusban először a ciklus feltétele lesz kiértékelve. Ez egy logikai kifejezés. Ha ez igaz értékű, akkor a ciklus folytatja a futását, ha kezdetben hamis, akkor a ciklusmag egyszer sem fog lefutni. Szintaxisa: while (logikai kifejezés) utasítás. A hátultesztelő ciklus a ciklusmag lefutása után vizsgálja meg a feltételt, ami, ha igaz, a ciklusmag újra lefut. Ha kezdetben hamis, akkor is egyszer le fog futni a ciklusmag. Szintaxisa: do utasítás while (logikai kifejezés). A léptető ciklus nem más, mint a for ciklus, melynek szintaxisa for (kezdet; logikai kifejezés; léptetés). A for ciklus fejrészében deklarált változók csak a cikluson belül lesznek érvényesek. A bejáró ciklussal egy adatszerkezet bejárását végezhetjük, ez lehet tömb, sorozat vagy halmaz. Szintaxisa: for (típus változó: gyűjtemény) utasítás.</para>
		<para>Beszélhetünk még címkékről is, ezek bármely utasítás elé írhatóak, az utasítás egyértelmű azonosítását teszik lehetővé. A break utasítást egy blokkból való kilépésre használjuk. Ha nem áll mellette címke, akkor a legbelső blokkból lép ki. A continue utasítással át lehet ugrani egy ciklus magjának hátralévő részét. Egy metódusból a return [kifejezés] utasítással térhetünk vissza.</para>
		<para>A kifejezések kiértékelési sorrendjét az operátorok határozzák meg. Először a legbelső zárójel kerül végrehajtásra, ha nincs zárójel, akkor a nagyobb prioritású operátor lesz végrehajtva. Ha több egyenlő prioritású operátor van, akkor balról jobbra haladunk. Beszélhetünk postfix operátorokról (tömb indexelése, minősített név, zárójelezett kifejezés, postfix csökkentő, illetve növelő operátorok) és prefix operátorokról (prefix csökkentő, illetve növelő műveletek, előjelváltás, logikai tagadó művelet, bitszintű nem művelet). Ezeken kívül léteznek még objektum létrehozására (new) és típuskényszerítésre ((típus)kifejezés) használható operátorok, valamint multiplikatív (*, /, %) és additív (+, -) operátorok, léptető műveletek, összehasonítások, egyenlőségvizsgálatok (==, !=), bitenkénti műveletek (~, |), logikai műveletek (||, stb.), feltételes kifejezés (? : operátor), és értékadások.  </para>
		<para>A Java egy erősen típusos nyelv, szinte minden esetben megvizsgálja, hogy a kifejezésekben összeegyeztethető típusok vannak-e. Az egyszerű típusok között végrehajthatunk értékadásokat, ha az értéket fogadó változó tartománya nagyobb, mint az eredeti. Egy adott osztály objektumának referenciáját bárhol fel lehet használni, ahol valamelyik ősosztályhoz tartozó típus van a kifejezésben. Ezek az automatikus konverziók közé tartoznak. Ha az előbb felsorolt konverziókat nem érjük el, vagy nem egyértelműek, akkor explicit módon is megadhatjuk őket, de ezek nem biztonságosak, vagy információvesztéssel járnak. Szövegek esetében, ha egy kifejezésben String típusra van szükség, de a kifejezésben lévő elem nem az, akkor a fordító meghívja az adott objektum toString metódusát. A szövegeket tudjuk konkatenálni a + operátorral, ebben az esetben is a toString metódus lesz meghívva. </para>
		<para>A Javában a legkisebb önálló egységek az osztályok, melyek azonos típusú dolgok modelljét írja le. Ezek létrehozására a class kulcsszót kell használnunk. a class szó előtt szerepelhetnek módosítók, pl public (az adott osztály hozzáférhető más csomagokból is), abstract vagy final. Ha valamelyik osztály nem public, akkor csak a saját csomagján belül használjuk. Az osztály fejlécében kell megadni azt is, hogy az adott osztályt melyik másik osztály kiterjesztéseként definiáljuk, illetve, hogy mely interfészeket valósítja meg. Osztályon belül tetszőlegesen felsorolhatjuk annak változóit és metódusait. Minden elemnek külön tudjuk szabályozni a láthatóságát, ez lehet public, ami mindenki számára látható, private, ami senki más számára nem látható, illetve protected, ami csak a leszármazottak számára látható. Osztályon belül a new operátorokkal hozhatunk létre új objektumokat. Az objektum egy elemére az objektum és az elem nevéből álló, ponttal elválasztott minősített névvel tudunk hivatkozni. Létezik egy spaciális referencia érték, a null, amely nem mutat egyetlen objektumra sem. A static kulcsszóval deklarált elemek nem az objektumhoz fognak tartozni, hanem az osztályhoz, ami azt jelenti, hogy a new operátor használatakor nem lesz számukra memóriaterület foglalva, az objektum adattagjainak inicializálásakor nem kell ezeknek is értéket adni, nemcsak az objektum, hanem osztály nevén keresztül is lehet rájuk hivatkozni. Itt is használunk különböző módosítókat. Vannak félnyilvános, nyilvános, privát és leszármazottban hozzáférhető tagok. Léteznek osztályváltozók, melyek olyan változók, amik magához az osztályhoz kapcsolódnak. Az osztálymetódusok az osztály példányain értelmezett műveleteket jelentik. Minden programban kell lennie egy main metódusnak, ami maga a főprogram. Léteznek konstruktorok, ezek olyan programkódok, melynek végrehajtása a példányisításkor automatikusan megtörténik. Annyiban különböznek a metódusoktól, hogy az azonosító kötött, nem szabad semmilyen visszatérési típust feltüntetni, és csak hozzáférési kategóriát meghatározó módosítókat alkalmazhatunk. Ezek törzsét úgy kell megírunk, mintha void metódus törzse lenne. Konstruktorok mellett beszélhetünk destruktorokról is, amiket akkor használunk, ha értesülni akarunk egy adott objektum megsemmisüléséről. Fontos, hogy a metódusunk protected void és paraméter nélküli legyen. Meghívása a finalize metódussal történik.</para>
		<para>Javában fontos az öröklődés fogalma. Legegyszerűbb esete az, amikor egy már létező osztályt szeretnénk kibővíteni új változókkal vagy metódusokkal. Az új osztály a bővítendő osztálytól függetlenül lehet public vagy nem public. Az osztálydefinícióban az extends kulcsszóval jelezzük, hogy melyik osztályt szeretnénk bővíteni. Az eredeti osztályt szülőosztálynak, míg a bővítettet gyerekosztálynak nevezzük. A gyermek csak azokhoz az elemekhez férhet hozzá, amelyeket a szülő engedélyez. Például a szülő private változóit a gyermek közvetlenül nem érheti el, azonban a szülő örökölt metódusain keresztül használhatja őket. A gyermek nem örökli a konstruktorokat. Ez úgy oldható meg, hogy a konstruktor törzsében a this kulcsszó helyett super-t használunk. Az osztályok rokonsági viszonyát osztályhierarchiának nevezzük. Az Object osztály egy kiemelt osztály, mely implicit módon minden olyan osztálynak szülője, amelynek definíciójában nem adtunk meg extends tagot.</para>
		<para>Az osztályok mellett a nyelv másik fontos építőkövei az interfészek. Egy interfész egy új referencia típus, absztrakt metódusok deklarációjának és konstans értékeknek az összessége. Itt hiányoznak a valódi változtatható adattagok, és a metódusokat is csak deklarálni lehet bennük. Használata implementáción keresztül történik. Egy osztály akkor implementál egy interfészt, ha az összes, az interfész által specifikált metódushoz implementációt ad. Az interfészek között is létezik öröklődés, annyi különbséggel, hogy itt lehet többszörös öröklődés. Egy interfész a következő módon épül fel: opcionális interfészmódosítók (public vagy abstract), név, az interfész által kiterjesztett interfészek (ha vannak), és az interfésztörzs.      </para>
		<para>Egy programozónak fontos arra is törekednie, hogy kódja átlátható és könnyen olvasható legyen. A Javában erre a célra úgynevezett csomagokat használunk. Minden csomag egy önálló namespace-t vezet be, amivel egyedivé teszi a benne definiált típusok nevét, ezzel elkerüljük az egyező változónevek keveredését. A csomagoknál is beállíthatjuk azok láthatóságát. A csomagok szerkezete hierarchikus, tehát köztük alárendelő viszony lehet. Egy csomagban tetszőleges számú alcsomag lehet. Az alcsomag annyiban különbözik a csomagtól, hogy megadják melyik csomagnak képezi a részét. Ennek megfelelően egy alcsomagnak is lehetnek további alcsomagjai. Egy csomag tartalmazhat alcsomagokat és típusokat. Ezek használatához kiterjesztett neveket kell majd használni. Új csomagot a package csomagdeklarációval hozhatunk létre. Emellett létezhetnek még névtelen csomagok. Ezek tárolása adatbázisban vagy fájlrendszerben történik. A JDK a fájlrendszerbeli tárolást támogatja. Adatbázisban történő tárolás esetén a csomagok, a fordítási egységek és a hozzájuk tartozó bájtkód kerül tárolásra. A fordítási egység az a hely, ahol a csomag kódja található. A csomagdeklaráció utáni lehetséges elemek az importdeklarációk. Ez lehetővé teszi más csomagokban deklarált publikus típusok, vagy más osztályokban deklarált statikus tagok egyszerű elérését. Az importdeklarációknak három fajtája van: egyszerű, igény szerinti, és statikus. Mindháromnál az import kulcsszót kell használni. Egyszerű típusimport-deklaráció esetében az import után egy típus kiterjesztett nevét kell megadni, ennek hatására a fordítási egységben a típus egyszerű nevét is lehet használni. Az igény szerinti típusimport-deklaráció arra jó, hogy ne csak egy meghatározott típust lehessen elérni a csomagból, hanem a csomag összes publikus típusát. Statikus importdeklaráció esetén minősítés nélkül lehet hivatkozni osztályváltozók értékeire. </para>
		<para>Egy metódus két részből áll, fejből és törzsből. a fej megadja a metódus visszatérési típusát, az azonosítóját, és a paramétereit. A fej előtt használhatunk módosítókat, például public, protected, private, abstract, static, final synchronized és native. A törzs a működést definiáló utasításblokkot tartalmazza. Javában a metódusokat is class kulcsszóval kell bevezetni. A metódus meghívásakor meg kell adnunk definíció szerint a paramétereit. Ezeket zárójelben vesszővel elválasztva tehetjük meg. Void típusú metódust akkor hívhatunk, ha nincs szükség visszatérési értékre. A törzsben a this pszeudováltozóval hivatkozhatunk az aktuális példányra.</para>
		<para>Fontos, hogy programunk megbízható legyen, és kivételes helyzetekben is meg tudjuk szabni annak menetét. Amikor valamilyen hiba lép fel a metódus futása során, akkor egy kivételobjektum jön létre, amely információkat tartalmaz a kivétel fajtájáról és a program futási állapotáról. A kivételeknek három fajtája lehet: program futása közben történt rendellenes dolog, a program egy throw utasítása váltott ki kivételt, vagy aszinkron kivétel lépett fel. A kivételek lehetnek ellenőrzöttek vagy nem ellenőrzöttek. Az ellenőrzötteket az kapcsolja össze, hogy mindig el kell kapni vagy specifikálni. ha egy program ennek nem tesz eleget akkor a fordító hibát jelez. Erre használjuk az exception handling-et. A throw kulcsszóval tudunk kivételt kiváltani. A try -catch-finally szerkezettel a kivételkezelőnek egy-egy blokkját lehet létrehozni. A try blokk vezérli a benne fellépő kivételek kezelését, meghatározza a blokkot követő catch ágak és finally ág érvényességi körét. Minden try blokk után következni kell egy ahhoz tartozó catch vagy finally blokknak. Lényeges a catch ágak sorrendje, mivel lehet olyan kivétel, amit több ág is kezel. A teljes kód lefutása után a következők történhetnek: nem lép fel kivétel, kivétel lépett fel és valamelyik catch ágon megy tovább a program, vagy a fellépett kivételt egyik catch ág sem kezeli. A finally után szereplő utasítások mindhárom esetben végrehajtódnak. A catch ágak a kivételeket úgy kezelik, hogy hibaüzeneteket írnak ki. A kivételek osztálya a java.lang.Throwable, aminek két gyermek osztálya van, a java.lang.Exception és a java.lang.Error. Az Error utódai a nem ellenőrzött kivételosztályok közé tartoznak és tetszőleges helyen bekövetkezhet. Az Exception-nek számos leszármazottja van, egyik ilyen a RuntimeException, mely futás idejű kivételeket kezel. A megbízhatóbb programok kezelése érdekében állításokat hozunk létre, amely program futása közben kiértékelődő logikai kifejezés, ami helyes működés esetén igaz értéket ad. Az állításoknak is több fajtája van: helyesség ellenőrzése tetszőleges ponton, program haladásának kontrollálása, és elő- és utófeltételek. </para>
		<para>A Java 5. verziójában megjelentek a generikusok, melyek segítségével az elvégzendő feladatokat típusokkal is paraméterezhetjük. A generikusokat különböző célokra használják: típusok feletti absztrakció, növekvő biztonság, egyszerű implementálhatóság, hatékonyság, kompatibilitás az eddig megírt Java kódokkal, és kompatibilitás a jövendőbeli fejlesztsekkel. Azt, hogy a korábban megírt kódokat és osztálykönyvtárakat megőrizhessük típustördelést kell használnunk. A típustördelés az az eljárás, amikor egy típust leképezünk egy másik, most már nem paraméteres típusra. Törés után az adott típus paraméter nélküli, azaz nyers (raw) verzióját kapjuk. Az Inner típus metódusa az Outer típusparaméterétől függ. Ha az Outer-t típusparaméter nélkül használjuk, akkor az Inner-hez sem köthetünk típust, az is nyers típus lesz. Egy generikus típusnak lehet static tagja. Ezek egy példányban léteznek az őket tartalmazó típusban, függetlenül az objektumok számától és attól, hogy hány féle paraméter típust alkalmazunk a generikusra. A generikusok bevezetése mögött az egyik legnagyobb motiváció a gyűjtemény keretrendszer biztonságossá tétele volt. Javában intenzíven használjuk az interfész fogalmát, minden olyan esetben, amikor az osztályok egy csoportjának valamilyen közös tulajdonságát szeretnénk leírni. Mivel a generikus és nem generikus osztályok egyaránt részt vehetnek az öröklődésben, számos kombinációt kell figyelembe vennünk: generikus osztály örököl nem generikustól, nem generikus osztály örököl egy konkrét típusparaméterrel ellátott generikustól, generikus osztály örököl egy általános generikustól, generikus osztály örököl egy generikus nyers típusától, nem származtathatunk nem-generikus osztályt generikus bázisból, nem működik a mixin konstrukció, amikor a generikus a típusparaméterétől örököl. Az atípusosság invariáns a típusparaméterekre, ami azt jelenti, hogy a típusparaméterek közötti öröklődés relációk teljesen közömbösek a generikus típusok közötti relációk szempontjából. A következők kivételével az összes referencia-típus lehet generikus: névtelen belső osztályok, kivétel típusok, felsorolási típusok.</para>
		<para>Javában megtalálhatóak különböző gyűjtemények is, melyek olyan típuskonstrukciós eszközök, melyeknek célja egy vagy több típusba tartozó objektumok példányainak memóriában történő összefoglaló jellegű tárolása, manipulálása, és lekérdezése. A halmaz interfész nem tartalmaz kifejezéseket a Collection interfészhez képest, csupán annak bizonyos metódusaira tesz megszorításokat. A halmazműveletek a következők: a containsAll metódus a tartalmazást segíti eldönteni, az addAll az uniót, a retainAll a metszet, a removeAll pedig a kivonás. A lista szintén a Collection interfész leszármazottja, mint List interfész. A listában az elemek duplikáltan is szerepelhetnek és lényeges a sorrendjük. A lista interfész tartalmaz néhány kiterjesztést, miszerint az elemeket pozíció szerint elérhetjük, tudunk keresni, valamit tartalmaz listaiterációt és részlista-kezelést. A listáknál a remove parancs csak a megadott elem legelső előfordulását törli, az add és az addAll műveletek a lista végére szúrják be az új elemeket. A FIFO adatszerkezeteket nevezzük még soroknak is, aminek az a lényege, hogy a legelőször betett objektumot tudjuk majd elsőnek kivenni. A sorokon a következő műveleteket hajthatjuk végre: az offerrel teszünk be új elemet a sorba, a remove és a poll metódusokkal vehetünk ki elemet, az element és a peek a legelső elemet adják vissza. A leképzés egy olyan adatszerkezet, amely kulcs-érték párokat tűrol, ennek megvalósítása a Map interfész. Minden kulcshoz csak egy érték tartozhat. Leképzések esetén szükség lehet különböző rendezésekre, ilyenkor lehet maga a gyűjtemény rendezett, vagy pedig egy rendező algoritmus segítségével sorba tesszük az elemeket. Ilyen algoritmus lehet például bináris keresés, minimum- és maximumkeresés, rotálás, helyettesítés, csere vagy gyakoriság lekérdezése.</para>
		<para>Egy Java program tervezése három szakaszra osztható: analízis, azaz a probléma megfogalmazása és körvonalazása, rendszertervezés, azaz a körvonalazott rendszer részekre bontása, osztálytervezés, azaz a rendszert alkotó osztályok és kapcsolataik kidolgozása. </para>
		<para>A C++-ban a memóriát háromféle módon használjuk: van statikus memória, amelyikben egy objektum számára a szerkesztőprogram a program futásának idejére foglal helyet, van automatikus memória, melyeben függvényargumentumok és a helyi változók kapnak helyet, valamint a szabad tár, melyet a programozó kezel. A Java programok virtuális gépen futnak, így a memóriát nem tudjuk elérni, csak szimbolikusan. C++-ban az objektumok élettartama pontosan ismert, az automatikus változók a deklaráló blokkba történő belépéskor keletkeznek, és pontosan a blokk végrehajtásáig élnek. A szabad tárban allokált objektumok élettartamát mi határozzuk meg. Javában egészen addig míg referenciánk van egy adott objektumra, az egészen addig él. A C++ nyelv többparadigmás, míg a Java csak az objektumorientált programozást támogatja. Fordításkor C-ben és C++-ban először az előfordító dolgozza fel a programot. Ilyen a Java-ban nincs. C++-ban bizonyos forrásállományokhoz headerekkel férünk hozzá. Ezt a program fejlécében #include paranccsal jelezzük. Erre Java nyelven nincs szükség. Java nyelvben nincsenek külön objektumok és mutatók, míg C++-ban többször is használnunk kell őket. Javában nincsen lehetőség a felhasználói operátorok definiálására. C++-ban egy függvény argumentumainak adhatunk alapértelmezett értéket, míg ilyen lehetőségJavában nincsen. A Java és a C++ utasításkészlete nagyon hasonlít. Java-ban megkülönböztetünk osztályokat és interfészeket. Osztályok körében a Java egyszeres öröklődést támogat, és nincs megkülönböztetés a private, public vagy protected öröklődés között.</para>
		
    </section>        

    <section>
        <title>Python</title>
        <para>
            Python: Forstner Bertalan, Ekler Péter, Kelényi Imre: Bevezetés a mobilprogramozásba.
			Gyors prototípus-fejlesztés Python és Java nyelven (35-51 oldal)
        </para>
		<para>
            Itt a kijelölt oldalakból egy 1 oldalas élmény-olvasónaplóra gondoltam.
        </para>

    </section>        
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>       